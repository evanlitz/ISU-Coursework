Teaching assistants, if you may read this, please understand that for some odd reason, you cannot open my file due to mingw blocking your permissions. I do not know why this is happening, but you're about to see a lot of Evan Litzer in your office hours. Get ready!
The first thing I changed for this assignment was my hardness initialization, which I had to recreate due to all stone/walls being set to 255. Now only the borders are set to 255, and the inner walls are set to a random number between 1 and 254.
Next I created three 2D arrays and 2 1D arrays. The 2D arrays include a non tunneling and tunneling integer map that are printed through the printDistanceMap function. The other is a visited array of bools that tracks if the djikistra's algorithm has visited the point yet (more on that later). The 1D arrays include a movesX and movesY array that represent the different directions the algorithm can take to visit other spaces in the 2D dungeon array. It is essential for algorithm movement. 
I also created a new struct--the point struct. These points are used by djikistras to store the shortest distance from the player along with its associated x and y position.
The calculateDistanceMap passes in the dungeonmap, hardness, and distanceMap (to be altered) 2D arrays, along with the playerX and playerY int positions. Finally, the bool tunnelMonster distinguishes function behavior between a tunneling and non-tunneling monster.
The visited array is set to completely false. Then the priority queue array is set, which is an array of the 1680 points in the dungeon. The points are currently uninitialized with no set attributes. The pqsize is set to 0 to represent an empty priority queue.
Then the distanceMap that is passed into is set to a million for all positions, then the player position (through passed in playerX and playerY) is set to 0 and added as a point to priority queue with distance 0.
Then the algorithm begins. While the priority queue size is bigger than 0, the priority queue is iterated through and each of the pq array points are checked for the smallest distance, which the minIndex is set to.
Then a current point variable is set to this point that has the smallest distance in the priority queue. It is then removed from the priority queue and its visited boolean is set to true.
Then the X/Y moves array is iterated through and its offset is set to the checkX and checkY integer variables, which are then checked for being out of bounds. These are the neighboring cells.
The weight (to be assigned to these check positions) is initially 1. 
If the function's parameter for tunnelMonster is true, the weight for nonbordering cells is set to 1 + the cell's hardness divided by 85.
If tunnelMonster is set to false, then the walls cannot be entered, so there is no distance value set to them. Nothing happens.
The checkDistance for the neighboring cell is then calculated by adding the current cell distance + the weight for the neighboring cell which was previously calculated for tunneling and non-tunneling monsters.
If this checkDistance is less than the set distance for the neighboring cell, then the distanceMap value for that particular neighboring cell is set to the newly calculated checkDistance and the priority queue is updated with the point, along with its size being updated by one.
In the main function, calculateDistanceMap is called twice, once each for tunneling and nonTunneling monsters with tunnelMonster set to true and false respectively. The two calls are accounted for normal and loading dungeon generation. Once the maps have been calculated and filled, they are then printed with printDistanceMap.
The printDistanceMap checks for player position and prints '@' at its location.
If it is a nontunnelingmonster and the distanceMap is set to a million or the dungeonMap is set to space for the iterating position, then a space is printed.
If it is a tunneling monster and the distanceMap for the position is set to a million, then a '#' char is printed representing a border.
Else, the module 10 of the set weight of the distance map is printed and a new line is printed for the next row of the distanceMap.