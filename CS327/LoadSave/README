The main method begins by taking input from the user for an argument of either --save or --load after calling ./dungeon. Based on the user choice, 
either loadDungeon or all of the dungeon creation methods and saveDungeon are called. 
For saveDungeon, the getEnvironment method for HOME is called first, which either gets home for linux/mac or %USERPROFILE% for Windows, which represents the home directory. If no such file is found, an error message is returned and the method call is broken.
Dirpath and filename are then constructed as an array of characters in order to ensure the filepath format is correctly formatted.
The filepath is then checked if it exists, before it is opened and checked for existence.
Then the file is written into with our required data. This starts out with the file version (which is 0 for now) and the file size that is calculated by totalRooms, numUpStairs, and numDownStairs. 
File size is first converted to big endian 32 bit format through the to_big_endian helper method.
For now, player position is set to the top left corner of the first room in the room array, and that is then written in as two unsigned 8 bit integers.
Then the hardness array is iterated through, with each array value being written in as an unsigned 8 bit integer.
Then totalRooms is converted into an unsigned 16 bit integer and is written in.
The room array of the dungeon is then iterated through, with each of the room structs attributes being stored in a room_data array of unsigned 8 bit ints anf being promptly written into the file.
Finally, upstair and downstair count are written in as the 16 bit unsigned versions of the big endian format numDown/numUpStairs, along with each of the upstair and downstair structs and their positions as uint8_t's. Then the file is closed.

For loadDungeon, the hardness and character array, player position pointers, and numRooms, numUp/DownStairs pointers are passed in.
The home directory is then accessed based on operating system, which is error checked. 
Then the filepath is initalized as an array of characters and set to the filepath and the dungeon_path, which is always /.rlg327/dungeon as defined at the beginning of the file. 
File is then attempted to be opened, posting an error message and a function break if it does not exist. 
Then a character array is created to hold a 12 char string and a null character. The first 12 bytes of the file are read, and the 12th position of the char array marker is null terminated.
If the marker does not equal RLG327-2025, an error is prompted as invalid file format and the file is closed.
Then the file version is read in and converted out of big endian 32, which is then error checked if it does not equal 0.
File size is then read in as a uint32_t and is converted out of 32 bit big endian.
Player X and Y position is read in as uint8_ts, which the passed in pointers are set to.
The room array is then cleared, and the hardness array is then read in as unsigned 8 bit integers, which each position of the hardness array is set to.
RoomCount is read in as an unsigned 16 bit integer and converted out of 16 bit big endian, then numRooms pointer is set to it.
The room array is then interated through, with each room's x,y,width,height are read in as uint8_ts and assigned to the room structs in the room array.
Then the dungeonMap character array is generated by checking hardness values and using the isInRoom array to distinguish between path and corridor.
Then, the numUp/DownStairs pointers are set to the read in uint16_t values and the staircase arrays are iterated through and their struct attributes are assigned through reading the file. The pointers for the stair counters are also assigned.
Finally, the dungeonMap sets the playerPosition x and y values are assigned to '@' and the file is closed.
The dungeon is then printed in the main function.
My main concern with this installment is that my program has these constraints that limit too many rooms or stairs, and this can interfere with loading the dungeon if it is not in bounds. This is a problem I will deal with later.